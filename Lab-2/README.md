# Computer Architecture  
## Assignment 2: Design Space Exploration with Gem5.
### Lab B / Group 7
#### Pougaridis Nikolaos 8038
#### Spaias Georgios 8910


## **Βήμα 1**

### Ερώτημα 1

Υλοιποιώντας το [runSpec_cpu2006.sh](https://github.com/PougasN/Comp_Arch/blob/main/Lab-2/runSpec_cpu2006.sh) και μέσα απο το παραγόμενο αρχείο [test_info.txt](https://github.com/PougasN/Comp_Arch/blob/main/Lab-2/test_info.txt) έχουμε τα παρακάτω δεδομένα.

| Parameter  | Value |
| ------------- | ------------- |
| Cache Line size  | 64  |
| L1 dcache size  | 64kB  |
| L1 dcache associativity  | 2  |
| L1 icache size  | 32kB  |
| L1 icache associativity  | 2  |
| L2 cache size  | 2MB  |
| L2 cache associativity  | 8  |

| ------------- | ------------- |-----|
system.cpu.committedInsts   |                100000001              |       # Number of instructions committed              |
system.cpu.committedOps      |               100196363              |        # Number of ops (including micro ops) committed |
system.clk_domain.clock      |                    1000              |         # Clock period in ticks       |
system.cpu_clk_domain.clock    |                   500              |          # Clock period in ticks     |


### Ερώτημα 2

Καταγράφοντας τα δεδομένα για τα εκάστοτε benchmark και χρησιμοποιώντας τις πληροφορίες για το καθένα από αυτά έχουμε τα παρακάτω γραφήματα:

![image](https://user-images.githubusercontent.com/81879767/146050784-4213a4bf-f145-4865-ac59-ce3112961eb3.png)
![image](https://user-images.githubusercontent.com/81879767/146051677-8ade9996-4542-4e66-8a31-14cefdd74884.png)
![image](https://user-images.githubusercontent.com/81879767/146051706-37002c9c-3872-4bb2-b609-de2f44fd1ed3.png)
![image](https://user-images.githubusercontent.com/81879767/146051718-73ed6040-cdd1-4e3e-a050-aca3bee29023.png)
![image](https://user-images.githubusercontent.com/81879767/146051730-5863c9de-f779-4932-bcbf-eaff05583113.png)


### Ερώτημα 3

Αρχικά με τα default options έχουμε: ``system.clk_domain.clock 1000`` και ``system.cpu_clk_domain.clock 500`` άρα ρολόι χρονισμού για την προσομοίωση στα 2GHz. Την 2η φορά έχουμε ``system.clk_domain.clock 1000`` και ``system.cpu_clk_domain.clock 667`` άρα ρολόι χρονισμού για την προσομοίωση στα 1.5GHz.

Τρέχουμε ξανά τα benchmarks αυτή τη φορά όμως με το ρολόι χρονισμένο στα 1,5 GHz (--cpu=clock=1.5GHz) και οι πληροφορίες που παίρνουμε παράγουν τα παρακάτω γραφήματα:

![image](https://user-images.githubusercontent.com/81879767/146051754-04ac2749-cab7-4f05-98e8-e911da9826e2.png)
![image](https://user-images.githubusercontent.com/81879767/146051764-1688846a-7325-403a-bff5-919805aedf20.png)
![image](https://user-images.githubusercontent.com/81879767/146051780-40985c70-ea7e-42f3-a07c-8d6d426ed994.png)
![image](https://user-images.githubusercontent.com/81879767/146051791-e660438d-029e-4c85-aade-7d755dc628fa.png)
![image](https://user-images.githubusercontent.com/81879767/146051799-73a156ef-d4c0-41b9-8b0b-e3ff46931815.png)

### Παρατηρήσεις: 

Παρατηρούμε ότι στα 2 GHz υπάρχει αισθητή μείωση του χρόνου εκτέλεσης. Μετά τη μεταβολή στο 1.5 GHz το CPI χειροτερεύει, με αύξηση 45.66% για το specsjeng, 25.48% για το ``speclibm`` και μόλις 0.83%, 0.19% και 4.38% για τα ``specmcf``, ``spechmmer`` και ``specbzip`` αντίστοιχα.

Απο τα παραπάνω καταλαβαίνουμε πως τα spechmmer kai specmcf έχουν ισχυρή εξάρτηση απο την συχνότητα του cpu.

Αντιθέτως, άλλα οπως ``specsjeng`` δεν εξαρτώνται πολύ απο την συχνότητα και δείχνουν μια ισχυρή εξάρτηση απο την δομή της Cache μνήμης.

Τέλος τα ``speclibm`` και ``specbzip`` επωφελούνται μεν απο μεγαλύτερη συχνότητα στον χρόνο εκτέλεσης τους αλλα παράλληλα αυξάνεται το CPI τους σε κάποιο βαθμό.

## **Βήμα 2**

Ο χώρος των δυνατών συνδιασμών για τα χαρακτηρστικά του simulation είναι πολυ μεγάλος ωστε να δοκιμάσουμε κάθε συνδιασμό για βελτιστοποίηση του συστήματος. Απο τα γραφήματα και τις πληροφορίες του βήματος 1 όμως, βλέπουμε τις αδυναμίες του setup μας για κάθε benchmark και συνεπώς μπορούμε να επικεντρωθούμε στους τομείς αυτούς.

Για την αυτοματοποίηση των Benchmark tests φτίαξαμε και χρησιμοποιήσαμε το shell script [**run_benchmarks.sh**](https://github.com/PougasN/Comp_Arch/blob/main/Lab-2/run_Benchmarks.sh) το οποίο παίρνει σαν Input ενα .ini αρχείο για την εισαγωγή των επιλογών και των πληροφοριών κάθε benchmark.

Έτσι απο τις πληροφορίες για το **cpi**, **L1_data miss rate**, **L1_instruction miss rate** και **L2 miss rate** κάνουμε για κάθε benchmark την εξής ανάλυση:

Στα παρακάτω διαγράμματα οι πληροφορίες για κάθε config παρουσιαζονται ως εξής:

``Cache_line_l1d_size_l1d_assoc_l1i_size_l1i_assoc_l2_size_l2_assoc``

### **Specbzip2**

Απο τα γραφήματα στο βήμα 1 καταλαβαίνουμε πως απαιτούνται αλλαγές κυρίως στην **L1 data cache** και ίσως στο **L2 cache**.  
Για το L1_d  βλεπουμε σχετικά αυξημένο miss rate επομένως:
  
  * Αυξάνουμε το μέγεθος (32kB->64kB).
  * Αυξάνουμε το Associativity (2->4).

Αντίστοιχα και στο L2 βλέπουμε σχετικά υψηλό miss rate και ετσι:

  * Αυξάνουμε το L2 size (2MB->4MB)
  * Aν δεν ήταν ηδη 8-way το associativity θα προτείνονταν αύξηση του.
  * Αύξηση του Cache line (64->128).

![bzip_cpi](https://github.com/PougasN/Comp_Arch/blob/main/Lab-2/Graphs/bzip2/bzip_cpi.png)

### **Specmcf**

Απο τις πληροφορίες του βήματος 1 βλέπουμε πως για το mcf πρέπει να εστιάσουμε στην **L1 Instruction cache**.  
Βλέπουμε στο L1_i υψιλό miss rate και συνεπώς προτείνεται:

* Αύξηση του L1_i size (32kB->128kB).
* Αύξηση του L1_i Associativity (2->8).

![mcf_cpi](https://github.com/PougasN/Comp_Arch/blob/main/Lab-2/Graphs/mcf/mcf_cpi.png)

### **Spechmmer**

To hmmer είχε ακόμα και με το default setup πολύ καλο cpi και χρόνο εκτέλεσης.Παρ'όλα αυτά, παρουσιάζει μικρή αυξηση στα miss rates των L1_Instruction Cache και L2 Cache.  
Επομένως ως βελτίωση για το L1_i προτείνεται:
  
  * Αύξηση του μεγέθους του L1_i (32kB->64kB).
  * Αύξηση του Associativity (2->4).

Kαι για το L2 cache προτείνεται:

* Αύξηση του L2 size (2MB-4MB).
* (Aν δεν ήταν ηδη 8-way το associativity θα προτείνονταν αύξηση του.)
  
![hmmer_cpi](https://github.com/PougasN/Comp_Arch/blob/main/Lab-2/Graphs/hmmer/hmmer_cpi.png)

### **Specsjeng**

Απο τα διαγράμματα του βήματος 1 βλέπουμε πως το sjeng παρουσιάζει πολύ υψιλό L1 Data Cache miss rate και πολύ υψιλό L2 miss rate.  

Έτσι, για την βελτίωση του L1 data cache θα πρέπει να:

* Αυξήσουμε το L1_d Size(64kB->128kB)
* Αυξήσουμε το Αssociativity (2->8)

Επιπλέον για την βελτίωση του L2 μπορούμε να:

* Αυξήσουμε το L2 Size (2MB->4MB)
* Αυξήσουμε το Cache Line μας (64->128)
  
![sjeng_cpi](https://github.com/PougasN/Comp_Arch/blob/main/Lab-2/Graphs/sjeng/sjeng_cpi.png)


### **Speclibm**

Τέλος για το libm βλέπουμ και πάλι αυξημένο miss rate στα L1 data cache και L2 cache και συνεπώς επικεντρωνομασται στην αλλγή αυτών.

Έτσι, για την βελτίωση του L1 data cache θα πρέπει να:

* Αυξήσουμε το L1_d Size(64kB->128kB)
* Αυξήσουμε το Αssociativity (2->8)

Για την βελτίωση του L2 μπορούμε να:

* Αυξήσουμε το L2 Size (2MB->4MB)
* Αυξήσουμε το Cache Line μας (64->128)

![libm_cpi](https://github.com/PougasN/Comp_Arch/blob/main/Lab-2/Graphs/libm/libm_cpi.png)

### **Σχόλια και Παρατηρήσεις**

  Αρχικά, όλες οι εκτελέσεις έγιναν με το **default frequency** των 2GHz και **-Ι instruction cap** στις 100.000.000 εντολές. Ο χρόνος εξομοίωασης των benchmarks ακόμα και το instruction cap αποδείχθηκε ιδιαίτερα μεγάλος και συνέπως δεν είχαμε την ευκαιρία να μελετήσουμε εκτενώς την επίδραση όλων των παραμέτρων.  
  Παρ'όλα αυτά μπορέσαμε να καταλήξουμε στα εξής:

  1. Μπορούμε να μειώσουμε σημαντικά τα miss rate τοσο στο L1 όσο και στο L2 με την αύξηση του **size** και του **associativity** και συνεπώς να βελτιώσουμε το cpi του προγράμματος μας.
   
  2. Σε περιπτώσεις, όπως αυτές των **speclibm** και **specsjeng**, οπου έχουμε αυξημένα miss rate τόσο στο L1 όσο και στο L2 βλέπουμε πως το μέγεθος της L2 δεν επιδρά τόσο στην βελτίωση του cpi. Η αύξηση του **Cache line** όμως φαίνεται να συμβάλει σημαντικά στην βελτίωση του cpi.
   
  3. Συνολικά, η αύξηση των παραπάνω παραμέτρων οδηγεί σε βελτίωση του cpi μέσω μείωσης του miss rate. Αλλά η βελτίωση του cpi επιτυγχάνεται και μέσω της μείωσης του hit time. Έτσι λοιπόν, βλέπουμε πως:
      * Η αύξηση τoυ **L1 Cache size** χωρίς την κατάλληλη προσαρμογή της L2, εχει μικρή επίδραση τελικά στο cpi.
      * Η αυξηση του **Associativity** για συγκεκριμένο μέγεθος cache αυξάνει την πολυπλοκότητα της cache και μετα απο ένα σημείο συμβάλει αρνητικά στην βελτίωση του cpi.
  

## **Βήμα 3**

### **Συνάρτηση Κόστους**

Για την συνάρτηση κόστους αθροίσαμε το κόστος που προκύπτει απο το μέγέθος, το associativity καθε cache level και απο cache line.

### Cache Size Cost

Γνωρίζουμε πως οι L1 και L2 υλοποιούνται συνήθως απο SRAM modules και θεωρήσαμε το κόστος της μνήμης είναι ανάλογο της ταχύτητας. Έτσι θεωρώντας πως η L1 ειναι 5 φόρες ταχύτερη της L2, θεωρούμε πως έχει και 5x κόστος.

```size_cost()=20*(sizeL1d+sizeL1i)/1024 + 5*sizeL2/1024 ```

όπου sizeL1d, sizeL1i και sizeL2 σε kB

### Cache Associativity Cost

H αυξηση του Associativity αυξάνει την πολυπλοκότητα της μνήμης και απαιτεί την χρήση περισσοτερων components όπως **multiplexers** και **comparators**. 
Για κάθε διπλασιασμό του Associativity λοιπόν απαιτείται διπλασιασμός των comparators και επιπλέον ενας MUX.

```assoc_cost=(assocL1d+log2(assocL1d)) + (assocL1i+log2(assocL1i)) + (assocL2+log2(assocL2))```
### Cache Line Cost

Για το cache line δεν βρέθηκαν αρκετες πληροφορίες και συνεπώς θεωρήθηκε πως το κόστος του είναι ανάλογο του μεγέθους του και κανονικοποιήθηκε στα επιπεδα των αλλων δυο μετρικών κόστους.

```cache_line_cost = cache_line/8```



Συνεπώς για κάθε Benchmark παιρνουμε τα παρακάτω κόστη:

### Bzip2



|L1d Size|l1d Assoc|l1i Size|l1i Assoc|l2 Size|l2 Assoc|Cache Line| Cost |
|--------|---------|--------|---------|-------|--------|----------|------|
| 64  | 2 | 64 | 2 | 2096 | 8 | 64  | 37.7343750000000 |
| 64  | 2 | 64 | 2 | 4096 | 8 | 64  |47.5000000000000 |
| 64  | 4 | 64 | 2 | 2096 | 8 | 64  |40.7343750000000 |
| 64  | 4 | 64 | 2 | 4096 | 8 | 64  |50.5000000000000 | 
| 128 | 2 | 64 | 2 | 2096 | 8 | 64  |38.9843750000000 |
| 128 | 2 | 64 | 2 | 4096 | 8 | 64  |48.7500000000000 |
| 128 | 4 | 64 | 2 | 2096 | 8 | 64  |41.9843750000000 |
| 128 | 4 | 64 | 2 | 4096 | 8 | 64  |51.7500000000000 |
| 64  | 2 | 64 | 2 | 2096 | 8 | 128 |45.7343750000000 |
| 64  | 2 | 64 | 2 | 4096 | 8 | 128 | 55.5000000000000 |
| 64  | 4 | 64 | 2 | 2096 | 8 | 128 |48.7343750000000 |
| 64  | 4 | 64 | 2 | 4096 | 8 | 128 |58.5000000000000 | 
| 128 | 2 | 64 | 2 | 2096 | 8 | 128 |46.9843750000000 | 
| 128 | 2 | 64 | 2 | 4096 | 8 | 128 |  56.7500000000000 |
| 128 | 4 | 64 | 2 | 2096 | 8 | 128 |  56.7500000000000 |
| 128 | 4 | 64 | 2 | 4096 | 8 | 128 |59.7500000000000 |

### Mcf


|L1d Size|l1d Assoc|l1i Size|l1i Assoc|l2 Size|l2 Assoc|Cache Line| Cost |
|--------|---------|--------|---------|-------|--------|----------|------|
| 64 | 4 | 32  | 2 | 2048 | 8 | 64 | 39.8750000000000 |
| 64 | 4 | 32  | 4 | 2048 | 8 | 64 | 42.8750000000000 |
| 64 | 4 | 32  | 8 | 2048 | 8 | 64 | 47.8750000000000 |
| 64 | 4 | 64  | 2 | 2048 | 8 | 64 | 40.5000000000000 |
| 64 | 4 | 64  | 4 | 2048 | 8 | 64 | 43.5000000000000 |
| 64 | 4 | 64  | 8 | 2048 | 8 | 64 | 48.5000000000000 |
| 64 | 4 | 128 | 2 | 2048 | 8 | 64 | 41.7500000000000 |
| 64 | 4 | 128 | 4 | 2048 | 8 | 64 | 44.7500000000000 |
| 64 | 4 | 128 | 8 | 2048 | 8 | 64 | 49.7500000000000 |


### Hmmr

|L1d Size|l1d Assoc|l1i Size|l1i Assoc|l2 Size|l2 Assoc|Cache Line| Cost |
|--------|---------|--------|---------|-------|--------|----------|------|
| 64 | 4 | 32 | 2 | 2048 | 8 | 64 | 39.8750000000000 |
| 64 | 4 | 32 | 2 | 4096 | 8 | 64 | 49.8750000000000 |
| 64 | 4 | 32 | 4 | 2048 | 8 | 64 | 42.8750000000000 |
| 64 | 4 | 32 | 4 | 4096 | 8 | 64 | 52.8750000000000 |
| 64 | 4 | 64 | 2 | 2048 | 8 | 64 | 40.5000000000000 |
| 64 | 4 | 64 | 2 | 4096 | 8 | 64 | 50.5000000000000 |
| 64 | 4 | 64 | 4 | 2048 | 8 | 64 | 43.5000000000000 |
| 64 | 4 | 64 | 4 | 4096 | 8 | 64 | 53.5000000000000 |


### Sjeng

|L1d Size|l1d Assoc|l1i Size|l1i Assoc|l2 Size|l2 Assoc|Cache Line| Cost |
|--------|---------|--------|---------|-------|--------|----------|------|
| 64  | 4 | 64 | 4 | 4096 | 8 | 64  | 53.5000000000000 |
| 64  | 8 | 64 | 4 | 4096 | 8 | 64  | 58.5000000000000 |
| 128 | 4 | 64 | 4 | 4096 | 8 | 64  | 54.7500000000000 |
| 128 | 8 | 64 | 4 | 4096 | 8 | 64  | 59.7500000000000 |
| 64  | 4 | 64 | 4 | 4096 | 8 | 128 | 61.5000000000000 |
| 64  | 8 | 64 | 4 | 4096 | 8 | 128 | 66.5000000000000 |
| 128 | 4 | 64 | 4 | 4096 | 8 | 128 | 62.7500000000000 |
| 128 | 8 | 64 | 4 | 4096 | 8 | 128 | 67.7500000000000 |

### Libm

|L1d Size|l1d Assoc|l1i Size|l1i Assoc|l2 Size|l2 Assoc|Cache Line| Cost |
|--------|---------|--------|---------|-------|--------|----------|------|
| 64  | 4 | 64 | 2 | 2048 | 8 | 64  | 40.5000000000000 |
| 64  | 4 | 64 | 2 | 4096 | 8 | 64  | 50.5000000000000 |
| 64  | 8 | 64 | 2 | 2048 | 8 | 64  | 45.5000000000000 |
| 64  | 8 | 64 | 2 | 4096 | 8 | 64  | 55.5000000000000 |
| 128 | 4 | 64 | 2 | 2048 | 8 | 64  | 41.7500000000000 |
| 128 | 4 | 64 | 2 | 4096 | 8 | 64  | 51.7500000000000 |
| 128 | 8 | 64 | 2 | 2048 | 8 | 64  | 46.7500000000000 |
| 128 | 8 | 64 | 2 | 4096 | 8 | 64  | 56.7500000000000 |
| 64  | 4 | 64 | 2 | 2048 | 8 | 128 | 48.5000000000000 |
| 64  | 4 | 64 | 2 | 4096 | 8 | 128 | 58.5000000000000 |
| 64  | 8 | 64 | 2 | 2048 | 8 | 128 | 53.5000000000000 |
| 64  | 8 | 64 | 2 | 4096 | 8 | 128 | 63.5000000000000 |
| 128 | 4 | 64 | 2 | 2048 | 8 | 128 | 49.7500000000000 |
| 128 | 4 | 64 | 2 | 4096 | 8 | 128 | 59.7500000000000 |
| 128 | 8 | 64 | 2 | 2048 | 8 | 128 | 54.7500000000000 |
| 128 | 8 | 64 | 2 | 4096 | 8 | 128 | 64.7500000000000 |



